<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>DSL TITLE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
    <script src="Sprite.js"></script>
    <script src="GameState.js"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div id="input-form">
    <form action="">
        <textarea id="input-area" name="input-area" rows="8" cols="50">Type here...</textarea>
        <br><br>
        <!--        todo submit won't start loop once everything is connected, also make this submit-->
        <input type="button" onclick="loop(seconds)" value="Submit">
        <button type="button" onclick="render()">Render</button>
        <br><br>
    </form>
</div>

<canvas id="canvas" width="0" height="0"></canvas>

<script>
    // set up canvas
    let canvas, ctx;
    const square_size = 30;
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");

    // todo this info reliant on input from user
    let width = 20;
    let height = 30;

    // set dimensions of grid
    //setup_grid(width, height);

    // load images
    let images = [
        'images/cat.png',
        'images/chicken.png',
        'images/grass.png',
        'images/path.png',
        'images/desert.png',
        'images/dirt.png',
        'images/egg.png',
        'images/fried_egg.png',
        'images/gold.png',
        'images/gold_feather.png',
        'images/ice.png',
        'images/lava.png',
        'images/meat.png',
        'images/potion.png',
        'images/rock.png',
        'images/scroll.png',
        'images/swamp.png'
    ];
    let loadedImages = {};

    let promiseArray = images.map(function (imgurl) {
        let prom = new Promise(function (resolve, reject) {
            let img = new Image();
            img.onload = function () {
                let name = imgurl.match(/([^\/]+)(?=\.\w+$)/)[0];
                loadedImages[name] = img;
                resolve();
            };
            img.src = imgurl;
        });
        return prom;
    });

    Promise.all(promiseArray).then(console.log("Image loaded"));

    // seconds of simulation
    seconds = 50;

    // graphics set up
    // todo this is all done elsewhere, evaluate?
    game_state = new GameState();
    game_state.make_grid(50, 50);
    game_state.draw_terrain_everywhere('ice');
    game_state.draw_terrain_by_rectangle('lava', 0, 0, 3, 3);

    // this starts filling up as the simulation begins
    items = [];

    // add sprites
    kitty = new Sprite('cat', 0, 0, width, height);
    kitty.drops = 'potion';
    kitty.moves = true;

    chicken = new Sprite('chicken', 1, 1, width, height);
    chicken.drops = 'gold_feather';
    chicken.moves = true;


    game_state.game_grid[kitty.x][kitty.y]["sprite"] = kitty;
    game_state.game_grid[chicken.x][chicken.y]["sprite"] = chicken;

    function loop(seconds) {
        console.log(seconds);
        milliseconds = seconds * 1000;

        // render every 0.25 seconds
        var intervals = setInterval(draw, 250);
        setTimeout(function () {
            clearInterval(intervals);
        }, milliseconds);

    }

    function draw() {
        console.log("Draw");
        setup_grid(game_state.grid_width, game_state.grid_height);


        // render terrain from game state matrix
        for (let i = 0; i < game_state.grid_height; i++) {
            for (let j = 0; j < game_state.grid_height; j++) {
                terrain_type = game_state.game_grid[i][j]["terrain"];
                terrain_img = loadedImages[terrain_type];
                ctx.drawImage(terrain_img, i * square_size, j * square_size, square_size, square_size);
            }
        }

        // render sprites from game state matrix todo there might be better way to do this
        for (let i = 0; i < game_state.grid_height; i++) {
            for (let j = 0; j < game_state.grid_height; j++) {
                sprite = null;
                if (game_state.game_grid[i][j]["sprite"] != undefined) {
                    // get sprite from matrix
                    sprite = game_state.game_grid[i][j]["sprite"];
                    sprite.move();
                    if (sprite.drop_counter > 4) {
                        sprite.drop_counter = 0;
                        item_type = sprite.drops;
                        item_img = loadedImages[item_type];
                        items.push(
                            {
                                img: item_img,
                                x: sprite.x,
                                y: sprite.y
                            });
                    }
                    for (let i = 0; i < items.length; i ++) {
                        img = items[i]["img"];
                        x = items[i]["x"];
                        y = items[i]["y"];
                        ctx.drawImage(items[i]["img"], x * square_size, y * square_size, (square_size/1.5), (square_size/1.5));
                    }
                    // render it
                    sprite_type = sprite.name;
                    sprite_img = loadedImages[sprite_type];
                    ctx.drawImage(sprite_img, sprite.x * square_size, sprite.y * square_size, square_size, square_size);
                }
            }
        }

        // render items


    }

    // render is for seeing the grid so far, without starting the simulation
    function render() {
        setup_grid(game_state.grid_width, game_state.grid_height);

        // render terrain from game state matrix
        for (let i = 0; i < game_state.grid_height; i++) {
            for (let j = 0; j < game_state.grid_height; j++) {
                terrain_type = game_state.game_grid[i][j]["terrain"];
                terrain_img = loadedImages[terrain_type];
                ctx.drawImage(terrain_img, i * square_size, j * square_size, square_size, square_size);
            }
        }

        // render sprites from game state matrix
        for (let i = 0; i < game_state.grid_height; i++) {
            for (let j = 0; j < game_state.grid_height; j++) {
                sprite = null;
                if (game_state.game_grid[i][j]["sprite"] != undefined) {
                    sprite = game_state.game_grid[i][j]["sprite"];
                    sprite_type = sprite.name;
                    sprite_img = loadedImages[sprite_type];
                    ctx.drawImage(sprite_img, sprite.x * square_size, sprite.y * square_size, square_size, square_size);
                }
            }
        }
    }

    // width, height inputted as squares on a grid
    function setup_grid(width, height) {
        // multiply by 10 to convert to pixels
        document.getElementById('canvas').width = width * 30;
        document.getElementById('canvas').height = height * 30;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function draw_by_rectangle(image, top_left_x, top_left_y, bottom_right_x, bottom_right_y) {
        for (let x = top_left_x; x <= bottom_right_x; x++) {
            for (let y = top_left_y; y <= bottom_right_y; y++) {
                ctx.drawImage(image, x * square_size, y * square_size, square_size, square_size);
            }
        }
    }

    function draw_all(image) {
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                ctx.drawImage(image, x * square_size, y * square_size, square_size, square_size);
            }
        }
    }

    function draw_by_coordinates(image, coordinates) {
        coordinates.forEach(function (item, index) {
            ctx.drawImage(image, item[0] * square_size, item[1] * square_size, square_size, square_size);
        });
    }

    // todo
    function draw_line(from, to, thickness) {

    }


    // todo
    function draw_anywhere(image, number_of_items) {
    }

</script>
</body>
</html>

